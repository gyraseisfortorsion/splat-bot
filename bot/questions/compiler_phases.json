[
  {
    "category": "concepts",
    "subcategory": "language_types",
    "question_text": "What is the difference between a compiled language and an interpreted language?",
    "option_a": "Compiled: translated to machine code before execution; Interpreted: executed line-by-line at runtime",
    "option_b": "Compiled: slower execution; Interpreted: faster execution",
    "option_c": "Compiled: requires interpreter; Interpreted: requires compiler",
    "option_d": "Compiled: Java; Interpreted: C",
    "option_e": "There is no difference",
    "correct_answer": "A",
    "explanation": "Compiled languages (C, C++) are translated entirely to machine code before execution, producing an executable file. Interpreted languages (Python, JavaScript) are executed line-by-line by an interpreter at runtime. Java is hybrid: compiled to bytecode, then interpreted/JIT-compiled by the JVM.",
    "difficulty": "easy"
  },
  {
    "category": "concepts",
    "subcategory": "parameter_passing",
    "question_text": "What is 'pass by value'? What about 'pass by reference'?",
    "option_a": "Pass by value: copy of value passed; Pass by reference: memory address passed",
    "option_b": "Pass by value: faster; Pass by reference: slower",
    "option_c": "Pass by value: for objects; Pass by reference: for primitives",
    "option_d": "Pass by value: modifies original; Pass by reference: doesn't modify original",
    "option_e": "They are the same thing",
    "correct_answer": "A",
    "explanation": "Pass by value: a copy of the argument's value is passed to the function. Changes to the parameter don't affect the original variable. Pass by reference: the memory address is passed, so changes to the parameter affect the original variable. Java uses pass by value for primitives and pass by value of references for objects.",
    "difficulty": "medium"
  },
  {
    "category": "lexer",
    "subcategory": "role",
    "question_text": "What is the role of the Lexer (Phase 1) in SPLAT?",
    "option_a": "Break source code into tokens and identify invalid characters",
    "option_b": "Build an Abstract Syntax Tree from tokens",
    "option_c": "Perform type checking and semantic analysis",
    "option_d": "Execute the program and produce output",
    "option_e": "Optimize the generated code",
    "correct_answer": "A",
    "explanation": "The Lexer (lexical analyzer) reads the source code character by character and groups them into tokens (keywords, identifiers, operators, literals). It also tracks line and column numbers and throws LexException for invalid characters. This is the first phase of compilation.",
    "difficulty": "easy"
  },
  {
    "category": "lexer",
    "subcategory": "implementation",
    "question_text": "In SPLAT's Lexer, why do we track line and column numbers?",
    "option_a": "To provide precise error locations when throwing exceptions",
    "option_b": "To optimize token storage",
    "option_c": "To improve parsing speed",
    "option_d": "To enable code formatting",
    "option_e": "To count total lines of code",
    "correct_answer": "A",
    "explanation": "Line and column numbers are stored with each token so that when an error occurs in any phase (Lexer, Parser, Semantic Analyzer, Executor), we can report exactly where the error occurred in the source code. This helps users debug their SPLAT programs.",
    "difficulty": "easy"
  },
  {
    "category": "parser",
    "subcategory": "role",
    "question_text": "What is the role of the Parser (Phase 2) in SPLAT?",
    "option_a": "Build an Abstract Syntax Tree (AST) from tokens according to grammar rules",
    "option_b": "Convert source code into tokens",
    "option_c": "Check variable types and function signatures",
    "option_d": "Execute statements and evaluate expressions",
    "option_e": "Generate machine code",
    "correct_answer": "A",
    "explanation": "The Parser reads tokens from the Lexer and organizes them into an Abstract Syntax Tree (AST) according to the language grammar. It uses recursive descent parsing and throws ParseException if the token sequence doesn't match the grammar rules.",
    "difficulty": "easy"
  },
  {
    "category": "parser",
    "subcategory": "recursive_descent",
    "question_text": "What is recursive descent parsing?",
    "option_a": "A top-down parsing technique where each grammar rule has a corresponding parsing method",
    "option_b": "A bottom-up parsing technique using shift-reduce operations",
    "option_c": "A way to eliminate left recursion from grammars",
    "option_d": "A method for handling ambiguous grammars",
    "option_e": "An optimization technique for parsers",
    "correct_answer": "A",
    "explanation": "Recursive descent parsing is a top-down parsing technique where: (1) Each non-terminal in the grammar has a parsing method, (2) Methods call each other recursively to match the grammar structure, (3) Lookahead is used to decide which production to apply. SPLAT uses this technique with methods like parseStatement(), parseExpression(), etc.",
    "difficulty": "medium"
  },
  {
    "category": "semantics",
    "subcategory": "role",
    "question_text": "What is the role of the Semantic Analyzer (Phase 3) in SPLAT?",
    "option_a": "Perform type checking, verify variable declarations, and validate scope rules",
    "option_b": "Build an Abstract Syntax Tree",
    "option_c": "Convert tokens into an executable program",
    "option_d": "Optimize code performance",
    "option_e": "Handle runtime errors",
    "correct_answer": "A",
    "explanation": "The Semantic Analyzer walks the AST and checks: (1) All variables/functions are declared before use, (2) Types match in assignments and operations (Integer vs Boolean), (3) Function calls have correct argument types and counts, (4) Return statements match function signatures. It throws SemanticAnalysisException for violations.",
    "difficulty": "easy"
  },
  {
    "category": "semantics",
    "subcategory": "type_checking",
    "question_text": "Why does SPLAT throw a SemanticAnalysisException for 'x := true' if x is declared as Integer?",
    "option_a": "Type mismatch: cannot assign Boolean value to Integer variable",
    "option_b": "Syntax error in the assignment",
    "option_c": "Variable x is not declared",
    "option_d": "The 'true' keyword is invalid",
    "option_e": "Assignment operator is incorrect",
    "correct_answer": "A",
    "explanation": "SPLAT is a statically-typed language. The semantic analyzer performs type checking to ensure that the type of the right-hand expression matches the type of the variable. 'true' is a Boolean literal, so it cannot be assigned to an Integer variable. This is caught in Phase 3 (Semantic Analysis).",
    "difficulty": "easy"
  },
  {
    "category": "executor",
    "subcategory": "role",
    "question_text": "What is the role of the Executor (Phase 4) in SPLAT?",
    "option_a": "Execute the AST by running statements and evaluating expressions at runtime",
    "option_b": "Check for type errors",
    "option_c": "Build the Abstract Syntax Tree",
    "option_d": "Convert tokens into machine code",
    "option_e": "Perform syntax validation",
    "correct_answer": "A",
    "explanation": "The Executor walks the AST and actually runs the program: (1) Executes statements (assignments, loops, conditionals, print), (2) Evaluates expressions and computes values, (3) Manages variable/function maps, (4) Handles function calls and returns. It throws ExecutionException for runtime errors like division by zero.",
    "difficulty": "easy"
  },
  {
    "category": "executor",
    "subcategory": "value_class",
    "question_text": "Why does SPLAT's Executor use a Value class instead of primitive types?",
    "option_a": "To represent runtime values polymorphically (IntValue, BoolValue) and handle different types uniformly",
    "option_b": "To improve execution speed",
    "option_c": "To reduce memory usage",
    "option_d": "To enable type checking",
    "option_e": "To simplify parsing",
    "correct_answer": "A",
    "explanation": "The Value class is an abstract class with subclasses IntValue and BoolValue. This allows the executor to: (1) Store different types in the same variable map, (2) Handle return values polymorphically, (3) Distinguish between Integer and Boolean at runtime. This is the Visitor pattern applied to runtime values.",
    "difficulty": "medium"
  },
  {
    "category": "splat",
    "subcategory": "exceptions",
    "question_text": "What are the four types of exceptions in SPLAT and which phase throws each?",
    "option_a": "LexException (Phase 1), ParseException (Phase 2), SemanticAnalysisException (Phase 3), ExecutionException (Phase 4)",
    "option_b": "SyntaxError, TypeError, RuntimeError, CompileError",
    "option_c": "TokenException, GrammarException, TypeError, RuntimeError",
    "option_d": "LexError, ParseError, SemanticError, RuntimeError",
    "option_e": "All phases throw the same SplatException",
    "correct_answer": "A",
    "explanation": "SPLAT has 4 exception types, one for each phase: (1) LexException - invalid characters (Lexer), (2) ParseException - syntax errors (Parser), (3) SemanticAnalysisException - type/scope errors (Semantic Analyzer), (4) ExecutionException - runtime errors like division by zero (Executor). All inherit from SplatException.",
    "difficulty": "easy"
  },
  {
    "category": "splat",
    "subcategory": "variable_defaults",
    "question_text": "What are the default values for uninitialized variables in SPLAT?",
    "option_a": "Integer: 0, Boolean: false",
    "option_b": "Integer: null, Boolean: null",
    "option_c": "Integer: 1, Boolean: true",
    "option_d": "Variables must be initialized before use",
    "option_e": "Integer: -1, Boolean: false",
    "correct_answer": "A",
    "explanation": "In SPLAT's Executor, when variables are declared but not initialized, they receive default values: Integer variables default to 0, Boolean variables default to false. This is important for understanding execution results and avoiding NullPointerExceptions.",
    "difficulty": "medium"
  }
]

[
  {
    "category": "cfg",
    "subcategory": "definition",
    "question_text": "What is a Context-Free Grammar (CFG)?",
    "option_a": "A set of rules that define the syntax of a programming language using productions",
    "option_b": "A type of automaton that recognizes regular languages",
    "option_c": "A method for optimizing compiler code generation",
    "option_d": "A data structure for storing parse trees",
    "option_e": "A technique for error recovery in parsers",
    "correct_answer": "A",
    "explanation": "A Context-Free Grammar (CFG) consists of: (1) A set of terminal symbols (tokens), (2) A set of non-terminal symbols (variables), (3) A set of production rules, and (4) A start symbol. CFGs define the syntax of programming languages.",
    "difficulty": "easy"
  },
  {
    "category": "cfg",
    "subcategory": "ambiguity",
    "question_text": "How do you prove a grammar is ambiguous?",
    "option_a": "Show that a string has two or more distinct parse trees",
    "option_b": "Show that the grammar has left recursion",
    "option_c": "Show that the grammar has right recursion",
    "option_d": "Show that the grammar has epsilon productions",
    "option_e": "Show that the grammar is context-sensitive",
    "correct_answer": "A",
    "explanation": "A grammar is ambiguous if there exists at least one string that can be derived in two or more different ways, producing different parse trees. To prove ambiguity, you must show two distinct leftmost (or rightmost) derivations for the same string.",
    "difficulty": "medium"
  },
  {
    "category": "cfg",
    "subcategory": "ambiguity",
    "question_text": "Is this grammar ambiguous?\nS → S + S | S * S | a",
    "option_a": "Yes - the string 'a+a*a' has multiple parse trees",
    "option_b": "No - the grammar is unambiguous",
    "option_c": "Cannot determine without more information",
    "option_d": "Yes - but only for strings with parentheses",
    "option_e": "No - operator precedence eliminates ambiguity",
    "correct_answer": "A",
    "explanation": "This grammar is ambiguous. For 'a+a*a', we can parse it as either ((a+a)*a) or (a+(a*a)), giving different parse trees. The grammar doesn't specify operator precedence or associativity, so multiplication and addition have equal precedence.",
    "difficulty": "medium"
  },
  {
    "category": "cfg",
    "subcategory": "bnf",
    "question_text": "In BNF notation, what does <expr> ::= <term> | <expr> + <term> mean?",
    "option_a": "An expression is either a term OR an expression followed by + and a term",
    "option_b": "An expression must be both a term AND an expression with +",
    "option_c": "An expression is optional",
    "option_d": "An expression is a terminal symbol",
    "option_e": "An expression can only contain addition operators",
    "correct_answer": "A",
    "explanation": "The '|' symbol in BNF means 'or' (alternative). This production says an <expr> can be derived as either: (1) just a <term>, or (2) an <expr> followed by '+' followed by a <term>. This allows for expressions like 'a', 'a+b', 'a+b+c', etc.",
    "difficulty": "easy"
  },
  {
    "category": "cfg",
    "subcategory": "parse_tree",
    "question_text": "Given grammar: S → aSb | ε\nWhat is the parse tree for string 'aabb'?",
    "option_a": "S → aSb → aaSbb → aaεbb → aabb",
    "option_b": "S → aSb → aabb",
    "option_c": "S → SS → aSb S → aabb",
    "option_d": "Cannot be parsed with this grammar",
    "option_e": "S → aabb (direct derivation)",
    "correct_answer": "A",
    "explanation": "To derive 'aabb': S ⇒ aSb ⇒ aaSbb ⇒ aaεbb = aabb. The parse tree shows S at the root, with children 'a', S, and 'b'. The middle S has children 'a', S, and 'b'. The innermost S derives to ε (empty string).",
    "difficulty": "medium"
  },
  {
    "category": "cfg",
    "subcategory": "terminals",
    "question_text": "In a CFG, what are terminal symbols?",
    "option_a": "Symbols that cannot be derived further (tokens like keywords, operators)",
    "option_b": "Symbols that can be replaced by production rules",
    "option_c": "Symbols that end a derivation",
    "option_d": "Symbols that represent the start of the grammar",
    "option_e": "Symbols used only in parse trees",
    "correct_answer": "A",
    "explanation": "Terminal symbols are the basic symbols (tokens) of the language that cannot be broken down further. In SPLAT, terminals include keywords ('program', 'begin', 'end'), operators (':=', '+', '-'), and literals (integers, strings). Non-terminals (like <expr>, <stmt>) can be derived into terminals.",
    "difficulty": "easy"
  },
  {
    "category": "cfg",
    "subcategory": "recursion",
    "question_text": "What is left recursion in a grammar?",
    "option_a": "When a non-terminal appears as the leftmost symbol in its own production",
    "option_b": "When a non-terminal appears as the rightmost symbol in its own production",
    "option_c": "When a production has multiple alternatives",
    "option_d": "When a grammar uses epsilon productions",
    "option_e": "When a grammar has cycles in its derivations",
    "correct_answer": "A",
    "explanation": "Left recursion occurs when a non-terminal A has a production A → Aα (A appears first on the right side). Example: E → E + T. This can cause problems for top-down parsers (like recursive descent) because they can enter infinite loops. Left recursion can be eliminated through grammar transformation.",
    "difficulty": "medium"
  },
  {
    "category": "cfg",
    "subcategory": "derivation",
    "question_text": "What is the difference between leftmost and rightmost derivation?",
    "option_a": "Leftmost replaces the leftmost non-terminal first; rightmost replaces the rightmost non-terminal first",
    "option_b": "Leftmost is used for parsing; rightmost is used for code generation",
    "option_c": "Leftmost produces different parse trees than rightmost",
    "option_d": "Leftmost is faster than rightmost",
    "option_e": "There is no difference - they produce the same results",
    "correct_answer": "A",
    "explanation": "In leftmost derivation, you always replace the leftmost non-terminal in each step. In rightmost derivation, you replace the rightmost non-terminal. Both produce the same parse tree for unambiguous grammars, but the sequence of derivation steps differs. Most top-down parsers use leftmost derivation; bottom-up parsers simulate rightmost derivation in reverse.",
    "difficulty": "medium"
  }
]
